### 普通堆存在的局限性
1. 如果堆中的元素是复杂的结构或很大的数据，那么每一次元素的交换位置的开销就会很大。
2. 在堆构建后，元素在数组中的索引位置发生了改变后，难以索引到想要的那个元素
  
# 索引堆

将数据和索引分开存储，而堆中存储的值其实是数据的索引。这样就使得堆构建过程中只是该改变了索引位置，而没有修改数据在数组中的位置。
![indexMaxHeap.png](../IMG/indexMaxHeap.png)

data数组，存储数据

reverse数组，根据元素找索引。
例如：找堆中第一个元素的索引。即 reverse[1] 即为这样元素在indexes中的位置

indexes数组，根据索引找元素。作为堆的结构。可以通过元素在堆中的逻辑位置找到对于的元素。
例如：找堆中的第一个元素的值，即data[ indexes[1] ] 


```
indexes[i] = j
reverse[j] = i

indexes[reverse[i]] = i
reverse[indexes[i]] = i
```
