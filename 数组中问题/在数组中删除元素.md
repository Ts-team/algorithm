# 在数组中删除元素

使用两个游标，一个游标来记录剩余元素的个数，即下一个非删除元素的位置。另一个游标则是遍历数组使用的变量

## 移动零 [leetcode - 283]

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

说明:
 - 必须在原数组上操作，不能拷贝额外的数组。
 - 尽量减少操作次数。


### 解法
使用一个for循环，找第一个0出现的位置并记录有0的存在。
然后碰到非0元素后，只要有0出现过，那么就把他和0那个位置交换，然后让指向0的索引加一
```js
var moveZeroes = function(nums) {
  let zeroPos = 0, findZeroPos = false;
  for(let i in nums) {
    if(nums[i] == 0 && !findZeroPos) {
      zeroPos = i;
      findZeroPos = true;
    }
    if(nums[i] != 0 && findZeroPos) {
      nums[zeroPos] = nums[i];
      zeroPos++;
      nums[i] = 0;
    }
  }
};
```

优化方法：上一个解法是直接赋值为0 ，但为了防止第一个数就是非0元素需要先找到一个0。
```js
var moveZeroes = function(nums) {
    
    let len = nums.length;
    let zeroPos = len;
    for(let i = 0; i< len; i++) {
        if(nums[i] == 0) {
            zeroPos = i;
            break;
        }
    }
    for(let i = zeroPos + 1; i < len; i++) {
        if(nums[i] != 0) {
          nums[zeroPos] = nums[i];
          zeroPos++;
          nums[i] = 0;
        }
    }
};
```

最快算法
```js
var moveZeroes = function(nums) {
  var pos = 0;
  
  for (var i = 0; i < nums.length; i++) {
    var num = nums[i];
    
    if (num !== 0) {
      nums[pos] = num;
      pos++;
    }
  }
  
  for (var j = pos; j < nums.length; j++) {
    nums[j] = 0;
  }
};
```

扫描一遍数组，将非0 元素全部拿出来，然后把这些元素填补到原数组的前面，后面直接赋值为0
```cpp
void moveZeroes(vector<int>& nums) {
  vector<int> nonZeroElement;
  for(int i = 0; i < nums.size(); i++){
    if(nums[i]) {
        nonZeroElement.push_back(nums[i]);
    }
  }
  for(int i = 0; i < nonZeroElement.size(); i++) {
      nums[i] = nonZeroElement[i];
  }
  for(int i = nonZeroElement.size(); i < nums.size(); i++) {
      nums[i] = 0;
  }
}
};
```


## 移除元素 leetcode 27
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
```

```js
var removeElement = function(nums, val) {
    var j = 0, len = nums.length;
    for(var i = 0; i < len; i++) {
        if(nums[i] !== val){
            nums[j] = nums[i];
            j ++;
        }
    }
    return j;
};
```

## 删除排序数组中的重复项 leetcode 26

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [0,0,1,1,1,2,2,3,3,4]
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
```

```js
var removeDuplicates = function(nums) {
    let j = 1;
    let num = nums[0];
    for(let i = 1; i < nums.length; i++){
        if(nums[i] !== num) {
            nums[j] = nums[i];
            num = nums[j];
            j++;
        }
    }
    return j;
};
```

```cpp
int removeDuplicates(int nums[], int length) {
  if( length <= 1) {
    return length;
  }
  int index = 1;
  for(int i = 1; i < length; i++) {
    if(nums[i] != nums[i - 1]) {
      nums[index++] = nums[i];
    }
  }
}
```


## 删除排序数组中的重复项 II  leetcode 80
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
```

```js
var removeDuplicates = function(nums) {

    let i = 0;
    for(let j in nums) {
        if(i < 2 || nums[j] != nums[i - 2]){
            nums[i++] = nums[j];
        }
    }
    return i;
};
```