# 快速排序

## 基本思想
通过partition操作将数组划分为两个部分，使得数组前一部分的元素都比数组的某一个元素小，数组的后一部分元素都比数组某一个元素大。

## 单路快排
设置3个索引， l, j，i。
从数组的第二个位置开始，依次遍历数组。如果ｉ元素大于ｌ元素，那么继续遍历下一个元素，ｉ++ ；如果ｉ元素小于ｌ元素，那么交换arr[j+1]与arr[i], 再让ｊ加一。
![单路快排](./IMG/oneRoad.gif)

## 缺点与优化
对于大多数O(n^2)级算法都可以优化的方法： 在数据量很小的时候使用插入排序进行优化。

### 缺点1：对近乎有序的数组性能很低
在面对近乎有序的数组时，快速排序的效率是非常低的。因为快速排序对数组的划分是以当前需排序区域的第一个位置的元素作为基准值来划分的。如果数组近乎有序，那么划分时形成的数的平衡度很差，即小于基准值的区间近乎为0，而大于基准值的区间则很大。这样就会使快速排序退化到O（n^2）级。
![worst](./IMG/worst.png)

#### 优化方法：

使用数组中间的那个元素作为待排序区间划分的基准值
```javascript
int __partition(T arr[], int left, int right) {

  //优化，使用数组中间元素作为基准元素
  swap(arr[left], arr[(left + right) / 2]);  
  int standard = arr[left];
  // arr[l+1, j] < standard ; arr[j+1, i] > standard
  int j = left;
  for(int i = left + 1; i <= right; i++) {
    if(arr[i] < standard) {
      swap(arr[j + 1], arr[i]);
      j++;
    }
  }
  swap(arr[left], arr[j]);
  return j;
}
```

### 缺点2：对于包含大量重复数据的数组性能很低
当数组中出现大量重复元素时，partition操作非常可能会将数组将会被分成两个极度不平衡部分。这是因为对于每一个键值重复的元素太多，导致划分出的两部分差异非常大，这也会导致数组退化成 O(n^2)级的算法。
![lotRepeat](./IMG/lotRepeat.png)

#### 优化方法
使用双路快拍，将等于基准值的元素划分到数组的两端。
![双路快拍](./IMG/twoRoad.gif)